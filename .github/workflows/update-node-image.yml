name: Update Node Image Tag

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */12 * * *"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: update-node-image
  cancel-in-progress: false

jobs:
  update:
    name: Check and Bump NODE_IMAGE
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Ensure jq installed
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Step 1 ‚Äî Current version from Dockerfile
        id: current
        shell: bash
        run: |
          set -euo pipefail

          echo ""
          echo "üîé  Reading current version from Dockerfile..."
          echo ""

          current_tag=$(sed -n 's/^ARG NODE_IMAGE=\(.*\)$/\1/p' Dockerfile)
          if [[ -z "$current_tag" ]]; then
            echo "‚ùå  Could not find current NODE_IMAGE in Dockerfile" >&2
            exit 1
          fi

          # Extract full semver prefix if present (e.g. 22.9.0 from 22.9.0-alpine)
          semver_prefix=$(echo "$current_tag" | cut -d'-' -f1)
          if [[ "$semver_prefix" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            current_version="$semver_prefix"
          else
            current_version=""
          fi

          # Extract major (prefer from semver; else from tag start)
          if [[ -n "${current_version}" ]]; then
            current_major=${current_version%%.*}
          else
            current_major=$(echo "$current_tag" | sed -n 's/^\([0-9][0-9]*\).*$/\1/p')
          fi

          echo "current_tag=$current_tag" >> "$GITHUB_OUTPUT"
          echo "current_version=$current_version" >> "$GITHUB_OUTPUT"
          echo "current_major=$current_major" >> "$GITHUB_OUTPUT"

          echo "‚úÖ  Current tag:        $current_tag"
          echo "‚úÖ  Current semver:     ${current_version:-N/A}"
          echo "‚úÖ  Current major:      ${current_major:-N/A}"
          echo ""

      - name: Step 2 ‚Äî Latest Node tags per architecture (curl with retries)
        id: latest
        shell: bash
        env:
          UA: NodeImageUpdater (+github.com/${{ github.repository }})
        run: |
          set -euo pipefail

          echo ""
          echo "üåê  Fetching latest Node alpine tags per architecture..."
          echo ""
          # Aggregate a few pages from Docker Hub tags API and compute per-arch latest N-alpine
          tmp=$(mktemp)
          echo '[]' > "$tmp"

          url="https://hub.docker.com/v2/repositories/library/node/tags?page_size=100"
          for page_idx in 1 2 3; do
            page=$(curl -fsSL -H "User-Agent: $UA" --retry 3 --retry-delay 2 --retry-connrefused --retry-all-errors "$url")
            # Merge results arrays
            jq -cs '.[0] + .[1]' "$tmp" <(echo "$page" | jq '.results') > "$tmp.new"
            mv "$tmp.new" "$tmp"
            next=$(echo "$page" | jq -r '.next // empty')
            [[ -n "$next" ]] || break
            url="$next"
          done

          # Compute latest N-alpine per architecture using the aggregated results
          amd64_tag=$(jq -r '
            [ .[]
              | select((.name|test("^[0-9]+-alpine$")) and (any(.images[]?; .os=="linux" and .architecture=="amd64")))
              | { name, major: ((.name | sub("-alpine$"; "") | tonumber)) }
            ]
            | if length>0 then (max_by(.major) | .name) else empty end
          ' "$tmp")

          arm64_tag=$(jq -r '
            [ .[]
              | select((.name|test("^[0-9]+-alpine$")) and (any(.images[]?; .os=="linux" and .architecture=="arm64")))
              | { name, major: ((.name | sub("-alpine$"; "") | tonumber)) }
            ]
            | if length>0 then (max_by(.major) | .name) else empty end
          ' "$tmp")

          armv7_tag=$(jq -r '
            [ .[]
              | select((.name|test("^[0-9]+-alpine$")) and (any(.images[]?; .os=="linux" and .architecture=="arm" and ((.variant // "") | ascii_downcase)=="v7")))
              | { name, major: ((.name | sub("-alpine$"; "") | tonumber)) }
            ]
            | if length>0 then (max_by(.major) | .name) else empty end
          ' "$tmp")

          rm -f "$tmp" || true

          if [[ -z "$amd64_tag" || -z "$arm64_tag" || -z "$armv7_tag" ]]; then
            echo "‚ùå  Failed to find per-arch tags: amd64='$amd64_tag' arm64='$arm64_tag' armv7='$armv7_tag'" >&2
            exit 1
          fi

          amd64_major=${amd64_tag%%-*}
          arm64_major=${arm64_tag%%-*}
          armv7_major=${armv7_tag%%-*}

          echo "amd64_tag=$amd64_tag" >> "$GITHUB_OUTPUT"
          echo "arm64_tag=$arm64_tag" >> "$GITHUB_OUTPUT"
          echo "armv7_tag=$armv7_tag" >> "$GITHUB_OUTPUT"
          echo "amd64_major=$amd64_major" >> "$GITHUB_OUTPUT"
          echo "arm64_major=$arm64_major" >> "$GITHUB_OUTPUT"
          echo "armv7_major=$armv7_major" >> "$GITHUB_OUTPUT"

          echo "‚úÖ  Latest amd64 tag:   $amd64_tag"
          echo "‚úÖ  Latest arm64 tag:   $arm64_tag"
          echo "‚úÖ  Latest armv7 tag:   $armv7_tag"
          echo ""

      - name: Step 3 ‚Äî Update Dockerfile and build workflow if newer
        id: update
        shell: bash
        run: |
          set -euo pipefail
          echo ""
          echo "üßÆ  Comparing versions and updating if needed..."
          echo ""
          # Use amd64 tag as default for Dockerfile
          amd64_tag='${{ steps.latest.outputs.amd64_tag }}'
          arm64_tag='${{ steps.latest.outputs.arm64_tag }}'
          armv7_tag='${{ steps.latest.outputs.armv7_tag }}'

          updated=false
          dockerfile_changed=false
          workflow_changed=false

          # 3a) Update Dockerfile default ARG to amd64 tag if changed
          current_tag='${{ steps.current.outputs.current_tag }}'
          if [[ "$current_tag" != "$amd64_tag" ]]; then
            echo "‚úèÔ∏è  Updating Dockerfile: $current_tag  ‚Üí  $amd64_tag"
            sed -i.bak -E "s/^(ARG NODE_IMAGE=).*/\\1${amd64_tag}/" Dockerfile
            rm -f Dockerfile.bak
            updated=true
            dockerfile_changed=true
          else
            echo "‚ÑπÔ∏è  Dockerfile already uses amd64 tag ($amd64_tag)"
          fi

          # 3b) Update per-arch node_image values in build workflow
          WF=.github/workflows/fetch-upstream-and-rebuild.yml
          awk -v a="$amd64_tag" -v b="$arm64_tag" -v c="$armv7_tag" '
            BEGIN{section=""}
            /- platform: linux\/amd64/ { section="amd64" }
            /- platform: linux\/arm64/ { section="arm64" }
            /- platform: linux\/arm\/v7/ { section="armv7" }
            section=="amd64" && $1=="node_image:" { print "            node_image: " a; next }
            section=="arm64" && $1=="node_image:" { print "            node_image: " b; next }
            section=="armv7" && $1=="node_image:" { print "            node_image: " c; next }
            { print }
          ' "$WF" > "$WF.tmp"

          if ! cmp -s "$WF" "$WF.tmp"; then
            mv "$WF.tmp" "$WF"
            echo "‚úèÔ∏è  Updated per-arch node_image in $WF"
            updated=true
            workflow_changed=true
          else
            rm -f "$WF.tmp"
            echo "‚ÑπÔ∏è  Build workflow already up-to-date"
          fi

          if [[ "$updated" == true ]]; then
            echo "updated=true" >> "$GITHUB_OUTPUT"
            echo "new_tag=$amd64_tag" >> "$GITHUB_OUTPUT"
          else
            echo "updated=false" >> "$GITHUB_OUTPUT"
          fi
          echo "dockerfile_changed=$dockerfile_changed" >> "$GITHUB_OUTPUT"
          echo "workflow_changed=$workflow_changed" >> "$GITHUB_OUTPUT"

      - name: Step 4a ‚Äî Commit and push directly (no workflow file changed)
        if: steps.update.outputs.updated == 'true' && steps.update.outputs.workflow_changed != 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo ""
          echo "üöÄ  Committing and pushing changes to trigger build..."
          echo ""
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add Dockerfile
          git commit -m "chore(docker): bump NODE_IMAGE to ${{ steps.update.outputs.new_tag }}"
          git push

      - name: Step 4b ‚Äî Open PR for workflow changes
        if: steps.update.outputs.updated == 'true' && steps.update.outputs.workflow_changed == 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            chore(ci): update per-arch node_image matrix and Dockerfile default to ${{ steps.update.outputs.new_tag }}
          title: "chore(ci): update node_image matrix and Dockerfile to ${{ steps.update.outputs.new_tag }}"
          body: |
            This PR updates:
            - Dockerfile default `ARG NODE_IMAGE` to `${{ steps.update.outputs.new_tag }}` (amd64 baseline)
            - Per-arch `node_image` values in the build matrix

            Once merged to `master`, it will trigger the Docker image rebuild workflow.
          branch: ci/bump-node-image-${{ steps.update.outputs.new_tag }}
          delete-branch: true

      - name: Step 4c ‚Äî Enable PR auto-merge (squash)
        if: steps.update.outputs.updated == 'true' && steps.update.outputs.workflow_changed == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        continue-on-error: true
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash

      - name: Step 4d ‚Äî Wait for checks and merge PR (squash)
        if: steps.update.outputs.updated == 'true' && steps.update.outputs.workflow_changed == 'true'
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
          PR_URL: ${{ steps.cpr.outputs.pull-request-url }}
          PR_BRANCH: ${{ steps.cpr.outputs.pull-request-branch }}
          REPO_OWNER: ${{ github.repository_owner }}
        shell: bash
        run: |
          set -euo pipefail
          echo ""
          echo "‚è≥  Waiting for checks to pass, then merging PR..."
          echo ""

          # Resolve PR number if missing (fallbacks: URL -> API by head branch)
          if [[ -z "${PR_NUMBER:-}" || "${PR_NUMBER}" == "null" ]]; then
            if [[ -n "${PR_URL:-}" && "${PR_URL}" != "null" ]]; then
              PR_NUMBER="${PR_URL##*/}"
            fi
          fi
          if [[ -z "${PR_NUMBER:-}" || "${PR_NUMBER}" == "null" ]]; then
            if [[ -n "${PR_BRANCH:-}" && "${PR_BRANCH}" != "null" ]]; then
              echo "üîé  Looking up PR number for branch: ${PR_BRANCH}"
              api="https://api.github.com/repos/${GH_REPO}/pulls?state=open&head=${REPO_OWNER}:${PR_BRANCH}"
              PR_NUMBER=$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "$api" | jq -r '.[0].number')
            fi
          fi

          if [[ -z "${PR_NUMBER:-}" || "${PR_NUMBER}" == "null" ]]; then
            echo "‚ùå  Could not resolve PR number for merge."
            exit 1
          fi

          echo "PR #${PR_NUMBER}"

          max_attempts=240 # ~2h at 30s interval
          attempt=0
          merged=false

          while [[ $attempt -lt $max_attempts ]]; do
            attempt=$((attempt+1))
            printf "Attempt %d: trying to merge PR #%s...\n" "$attempt" "$PR_NUMBER"

            status=$(curl -sS -o /tmp/merge.json -w '%{http_code}' \
              -X PUT \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${GH_REPO}/pulls/${PR_NUMBER}/merge" \
              -d '{"merge_method":"squash"}') || status=000

            if [[ "$status" == "200" ]]; then
              echo ""
              echo "‚úÖ  PR merged successfully."
              merged=true
              break
            fi

            echo "‚ÑπÔ∏è  Merge not yet possible (HTTP $status)."
            cat /tmp/merge.json || true

            # 405/409 are typical for not mergeable yet, retry later
            if [[ "$status" == "405" || "$status" == "409" || "$status" == "202" ]]; then
              sleep 30
              continue
            fi

            echo "‚ùå  Unexpected error while attempting to merge (HTTP $status)."
            exit 1
          done

          if [[ "$merged" != true ]]; then
            echo "‚ùå  Timed out waiting to merge PR. Please merge manually: https://github.com/${GH_REPO}/pull/${PR_NUMBER}"
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          if [[ "${{ steps.update.outputs.updated }}" == "true" ]]; then
            if [[ "${{ steps.update.outputs.workflow_changed }}" == "true" ]]; then
              printf "\n‚úÖ  Changes prepared. Opened PR to update workflow matrix and Dockerfile.\n"
              printf "üîó  %s\n\n" "${{ steps.cpr.outputs.pull-request-url }}"
            else
              printf "\n‚úÖ  Node base image updated to %s.\n" "${{ steps.update.outputs.new_tag }}"
              printf "üß±  Push to master triggers Docker image build workflow.\n\n"
            fi
          else
            printf "\n‚úÖ  Node base image already up-to-date.\n\n"
          fi
